<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
    <script>
    let board=[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
                1,2,1,0,1,0,1,0,1,1,1,0,1,1,1,0,0,0,0,0,1,
                1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,
                1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,
                1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,
                1,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,
                1,0,1,0,1,0,0,0,1,0,1,1,1,1,1,0,1,0,1,0,1,
                1,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,
                1,0,1,0,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,
                1,0,1,0,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,
                1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,0,1,
                1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,1,0,1,
                1,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,1,
                1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,0,1,
                1,0,1,0,1,0,0,0,1,0,1,0,1,1,1,0,1,0,1,0,1,
                1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,3,
                1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
        let x=0,y=0 ,endx=1,endy=1;

     window.onload=function(){
        draw();

        /*
        window.onload 안에 함수를 넣어두면
        시작하자마자 해당 함수가 실행되도록 할 수 있음
        */
        
     }
     function draw(){
        /*
        createElemet 같은 함수를 사용하는 것이 아니라
        out에 table 관련 태그들을 구겨 넣어서 표시되도록 한 것
        */
        let miro = document.getElementById("miro");
        var out="<table>";
        for(var i=0; i<17; i++){
            /*17회 반복문은 세로줄을 만들때 쓰이므로,
            out에 <tr>을 넣어주는 명령을 한다.*/
            out += "<tr>";
            /*아래 반복문까지 합쳐서, 21개의 칸을 만드는 명령이 17회 반복되게 된다.
            각 반복문에는 i와 k라는 다른 변수를 썼는데, 때문에 i는 y축이 되고 k는 가로축이 된다.*/
            for(var k=0; k<21; k++){
                /*
                이는 곧 board 배열 안의 값들을 [i*21+k]로 훑어줄 수 있다는 뜻이 된다.
                (가로열 하나가 21개의 칸으로 되어있기에, y축인 i에 21을 곱해주면 줄이 바뀐다.
                거기에 k로 x축 값을 더해주면 결과적으로 배열 내의 모든 값을 훑어줄 수 있다.)
                */
                if(board[i*21+k]==1) // 1을 만나면 class가 wall인 td를 생성해준다.
                    out +="<td class=wall></td>"
                if(board[i*21+k]==0) // 0을 만나면 이름없는 td를 생성해준다.
                    out +="<td></td>";
                if(board[i*21+k]==2) // 다른 숫자를 사용함으로서 새로운 블록을 만들 수도 있다.
                    out +="<td>도착</td>";
                if(board[i*21+k]==3){
                    out +="<td class=me></td>";
                    x=k;
                    y=i;
                    /*3을 쓴 위치를 x, y라는 변수에 저장해주었다.
                    move(e) 함수에서 다시 응용할 예정이다.*/
                }
            }
            out += "</tr>"; 
            /*가로21줄 생성 반복문 이후, 다시 세로줄 생성 반복문이 시작되기 직전의 위치다.
            여기에 tr의 닫는 태그를 넣어서 봉합해준다.*/
        }
        out+="</table>"; // 모든 반복문이 끝난 이후 닫는 table태그도 넣어준다.
        miro.innerHTML=out; // 모든 공정의 결과를 출력
     }


     document.addEventListener("keypress",move);
     /*key를 누를시 move라는 함수를 실행시키도록 이벤트를 걸었다.*/

     function move(e){ // e는 keypress에서 입력한 값이 들어갈 매개변수다.
        var k=e.key; // 매개변수에 들어간 입력값에 .key 함수를 씌우주고 k에 저장함으로서 정리
        board[y*21+x]=0;
        /*x와 y에 3의 위치가 저장되어 있으니, 해당 위치의 값을 쉽게 바꿀 수 있게 된다.
        함수가 발동하는 순간, 3이 있었던 위치의 내부값을 0으로 바꿔주는 이유는
        그곳이 이제부터 3이 있는 곳이 아니라 빈 공간이 되어야 하기 때문이다.
        (3은 이미 다른 곳으로 이동했으니까)*/
        switch(k){ // k에 어떤 값이 들어오느냐에 따라 case로 반응을 도출한다.
            case "a":
                if(board[y*21+(x-1)]!=1) // 이동하게 될 칸이 1(벽)이 아니라면(!=) 
                    x--; // 다시 말해 좌측 이동
                break; // 동작 이후 switch 끝
            case "s":
            if(board[(y+1)*21+x]!=1) // 이동하게 될 칸이 1(벽)이 아니라면(!=) 
                y++; // 다시 말해 아래쪽 이동
                break; // 동작 이후 switch 끝
            case "d":
            if(board[y*21+(x+1)]!=1) // 이동하게 될 칸이 1(벽)이 아니라면(!=) 
                x++; // 다시 말해 우로 이동
                break; // 동작 이후 switch 끝
            case "w":
            if(board[(y-1)*21+x]!=1) // 이동하게 될 칸이 1(벽)이 아니라면(!=) 
                y--; //  다시 말해 위로 이동
                break; // 동작 이후 switch 끝
        }

        board[y*21+x]=3;
        /*switch에 의해서 변경된 3의 자리를 새로 표시해주는 것*/

        draw();
        /*위에서 한 공정들에 따라 draw()함수를 실행해서 새로 그려줌
        */


        if( endx==x && endy==y){
            /*exdx와 exdy는 그냥 도착 td가 있는 좌표를 말하고,
            해당 좌표에 x와 y값이 맞춰졌을 때 알람을 띄우도록 한 것이다.*/
            alert("끝");
        }
     }
    </script>

    <style>
        table{border-spacing: 0;}
        table tr td{width:30px; height:30px;}
        .wall{background:black;}
        .me{background:red;}
    </style>
</head>

<body>
    <div id="miro"></div>
</body>
</html>